schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type AccessTokenListDto {
  createdAt: DateTime!
  expiresAt: DateTime
  id: String!
  isExpired: Boolean!
  lastUsed: DateTime
  name: String!
  scopes: [String!]
  token: String
}

type AccessTokenResponseDto {
  createdAt: DateTime!
  expiresAt: DateTime
  id: String!
  name: String!
  token: String!
  tokenStored: Boolean!
}

input AdminCreateUserInput {
  email: String!
  password: String!
  skipEmailConfirmation: Boolean
  username: String!
}

input ApproveSystemAccessTokenRequestDto {
  expiresAt: String
}

type Attachment {
  createdAt: DateTime!
  filename: String!
  filepath: String!
  id: ID!
  mediaType: MediaType
  messageId: String
  originalFilename: String
  size: Float
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type BackupInfoDto {
  createdAt: DateTime!
  filename: String!
  path: String!
  size: String!
  sizeBytes: Float!
}

input BatchUpdateSettingInput {
  configType: ServerSettingType!
  valueBool: Boolean
  valueNumber: Float
  valueText: String
}

type Bucket {
  color: String
  createdAt: DateTime!
  description: String
  externalNotifySystem: ExternalNotifySystem
  externalSystemChannel: String
  icon: String
  iconAttachmentUuid: String
  iconUrl: String
  id: ID!
  isAdmin: Boolean
  isProtected: Boolean
  isPublic: Boolean
  messages: [Message!]
  name: String!
  permissions: [EntityPermission!]!
  preset: String
  updatedAt: DateTime!
  user: User!
  userBucket: UserBucket
  userBuckets: [UserBucket!]
  userPermissions: ResourcePermissionsDto!
}

input ChangePasswordInput {
  currentPassword: String!
  newPassword: String!
}

type Changelog {
  """Whether this changelog is active and should be shown"""
  active: Boolean!
  """Android app version"""
  androidVersion: String!
  """Backend/server version"""
  backendVersion: String!
  createdAt: DateTime!
  """Combined changelog description"""
  description: String!
  """Structured changelog entries (type + text)"""
  entries: [ChangelogEntry!]
  id: ID!
  """iOS app version"""
  iosVersion: String!
  """Web/UI version"""
  uiVersion: String!
  updatedAt: DateTime!
}

type ChangelogEntry {
  text: String!
  type: String!
}

input ChangelogEntryInput {
  text: String!
  type: String!
}

input ConfirmEmailDto {
  code: String!
  locale: String
}

input CreateAccessTokenDto {
  expiresAt: DateTime
  name: String!
  scopes: [String!]
  storeToken: Boolean
}

input CreateBucketDto {
  color: String
  description: String
  externalNotifySystemId: String
  externalSystemChannel: String
  generateIconWithInitials: Boolean
  generateMagicCode: Boolean
  icon: String
  isProtected: Boolean
  isPublic: Boolean
  name: String!
  preset: String
}

input CreateChangelogInput {
  active: Boolean
  androidVersion: String
  backendVersion: String
  description: String!
  entries: [ChangelogEntryInput!]
  iosVersion: String
  uiVersion: String
}

input CreateExternalNotifySystemDto {
  authPassword: String
  authToken: String
  authUser: String
  baseUrl: String!
  color: String
  iconUrl: String
  name: String!
  type: ExternalNotifySystemType!
}

input CreateInviteCodeInput {
  """Expiration date (ISO string)"""
  expiresAt: String
  """Maximum number of uses"""
  maxUses: Int
  """Permissions to grant"""
  permissions: [String!]!
  """Resource ID"""
  resourceId: String!
  """Resource type"""
  resourceType: String!
}

input CreateMessageDto {
  actions: [NotificationActionDto!]
  addDeleteAction: Boolean = true
  addMarkAsReadAction: Boolean = true
  addOpenNotificationAction: Boolean
  attachmentUuids: [String!]
  attachments: [NotificationAttachmentDto!]
  body: String
  bucketId: String
  collapseId: String
  deliveryType: NotificationDeliveryType!
  ephemeral: Boolean
  executionId: String
  gifUrl: String
  groupId: String
  imageUrl: String
  locale: String
  magicCode: String
  maxReminders: Float
  postpones: [Float!]
  remindEveryMinutes: Float
  scheduledSendAt: DateTime
  snoozes: [Float!]
  sound: String
  subtitle: String
  tapAction: NotificationActionDto
  tapUrl: String
  title: String!
  userIds: [String!]
  videoUrl: String
}

input CreateOAuthProviderDto {
  additionalConfig: String
  authorizationUrl: String
  callbackUrl: String
  clientId: String!
  clientSecret: String!
  color: String
  iconUrl: String
  isEnabled: Boolean
  name: String!
  profileFields: [String!]
  scopes: [String!]!
  textColor: String
  tokenUrl: String
  type: OAuthProviderType!
  userInfoUrl: String
}

input CreatePayloadMapperDto {
  jsEvalFn: String!
  name: String!
  requiredUserSettings: [UserSettingType!]
  userId: String
}

input CreateSystemAccessTokenRequestDto {
  description: String
  maxRequests: Int!
}

input CreateUserLogInput {
  payload: JSON!
  type: UserLogType!
  userId: String
}

input CreateUserTemplateDto {
  body: String!
  description: String
  name: String!
  subtitle: String
  title: String
}

input CreateWebhookDto {
  body: JSON
  headers: [WebhookHeaderDto!]!
  method: HttpMethod!
  name: String!
  url: String!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DeclineSystemAccessTokenRequestDto {
  reason: String
}

input DeviceInfoDto {
  deviceModel: String
  deviceName: String
  osVersion: String
  platform: String
}

"""Platform types for devices"""
enum DevicePlatform {
  ANDROID
  IOS
  WEB
}

type EmailConfirmationResponseDto {
  message: String!
  success: Boolean!
}

type EmailStatusResponseDto {
  confirmed: Boolean!
  message: String!
}

type EntityExecution {
  createdAt: DateTime!
  durationMs: Float
  entityId: String
  entityName: String
  errors: String
  id: ID!
  input: String!
  output: String
  status: ExecutionStatus!
  type: ExecutionType!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type EntityPermission {
  createdAt: DateTime!
  expiresAt: DateTime
  grantedBy: User
  id: ID!
  """Invite code ID used to create this permission"""
  inviteCodeId: String
  permissions: [Permission!]!
  resourceId: String!
  resourceType: String!
  updatedAt: DateTime!
  user: User!
}

type Event {
  additionalInfo: JSON
  createdAt: DateTime!
  id: String!
  objectId: String
  targetId: String
  type: EventType!
  userId: String
}

"""Tracked event type"""
enum EventType {
  ACCOUNT_DELETE
  BUCKET_CREATION
  BUCKET_DELETION
  BUCKET_SHARING
  BUCKET_UNSHARING
  DEVICE_REGISTER
  DEVICE_UNREGISTER
  EMAIL_FAILED
  EMAIL_SENT
  LOGIN
  LOGIN_OAUTH
  LOGOUT
  MESSAGE
  NOTIFICATION
  NOTIFICATION_ACK
  NOTIFICATION_FAILED
  PUSH_PASSTHROUGH
  PUSH_PASSTHROUGH_FAILED
  REGISTER
  SYSTEM_TOKEN_REQUEST_APPROVED
  SYSTEM_TOKEN_REQUEST_CREATED
  SYSTEM_TOKEN_REQUEST_DECLINED
  USER_FEEDBACK
}

input EventsQueryDto {
  limit: Int = 20
  objectId: String
  objectIds: [String!]
  page: Int = 1
  targetId: String
  type: EventType
  userId: String
}

type EventsResponseDto {
  events: [Event!]!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  limit: Int!
  page: Int!
  total: Int!
  totalPages: Int!
}

"""Status of the execution"""
enum ExecutionStatus {
  ERROR
  SKIPPED
  SUCCESS
  TIMEOUT
}

"""Types of executions that are tracked"""
enum ExecutionType {
  MESSAGE_TEMPLATE
  NOTIFICATION
  PAYLOAD_MAPPER
  WEBHOOK
}

type ExternalNotifySystem {
  authPassword: String
  authToken: String
  authUser: String
  baseUrl: String!
  color: String
  createdAt: DateTime!
  iconUrl: String
  id: ID!
  name: String!
  permissions: [EntityPermission!]!
  type: ExternalNotifySystemType!
  updatedAt: DateTime!
  user: User!
  userPermissions: ResourcePermissionsDto!
}

"""
Type of external notification system (each has its own publish/subscribe implementation)
"""
enum ExternalNotifySystemType {
  Gotify
  NTFY
}

type FileInfoDto {
  isDir: Boolean!
  mtime: DateTime!
  name: String!
  size: Float!
}

type FileInfoWithPathDto {
  fullPath: String!
  isDir: Boolean!
  mtime: DateTime!
  name: String!
  size: Float!
}

input GetEntityExecutionsInput {
  entityId: String
  entityName: String
  type: ExecutionType
  userId: String
}

input GetLogsInput {
  context: String
  level: LogLevel
  limit: Int = 50
  page: Int = 1
  search: String
}

input GetResourcePermissionsInput {
  resourceId: String!
  resourceType: ResourceType!
}

input GetUserLogsInput {
  limit: Int = 50
  page: Int = 1
  search: String
  type: UserLogType
  userId: String
}

input GrantEntityPermissionInput {
  expiresAt: String
  permissions: [Permission!]!
  resourceId: String!
  resourceType: ResourceType!
  userEmail: String
  userId: String
  username: String
}

"""HTTP methods for webhooks"""
enum HttpMethod {
  DELETE
  GET
  PATCH
  POST
  PUT
}

type InviteCode {
  """Unique invite code"""
  code: String!
  createdAt: DateTime!
  """User who created this code"""
  createdBy: String!
  creator: User!
  """Expiration date for this code"""
  expiresAt: String
  id: String!
  """Maximum number of uses (null = unlimited)"""
  maxUses: Float
  """Permissions granted by this code"""
  permissions: [String!]!
  """Resource ID this code grants access to"""
  resourceId: String!
  """Resource type (BUCKET, etc.)"""
  resourceType: String!
  updatedAt: DateTime!
  """Number of times this code has been used"""
  usageCount: Float!
}

type InviteCodeRedemptionResult {
  """Error message if redemption failed"""
  error: String
  """Permissions that were granted"""
  permissions: [String!]
  """Resource ID that was granted access to"""
  resourceId: String
  """Resource type that was granted access to"""
  resourceType: String
  """Whether redemption was successful"""
  success: Boolean!
}

"""JSON custom scalar type"""
scalar JSON

type Log {
  context: String
  createdAt: DateTime!
  id: ID!
  level: LogLevel!
  message: String!
  metadata: JSON
  timestamp: DateTime!
  trace: String
}

"""Log level enum"""
enum LogLevel {
  DEBUG
  ERROR
  HTTP
  INFO
  SILLY
  VERBOSE
  WARN
}

input LoginDto {
  deviceInfo: DeviceInfoDto
  email: String
  password: String!
  username: String
}

type LoginResponse {
  accessToken: String!
  message: String
  refreshToken: String!
  user: User!
}

type MarkAllAsReadResult {
  success: Boolean!
  updatedCount: Float!
}

type MassDeleteResult {
  deletedCount: Float!
  success: Boolean!
}

type MassMarkResult {
  success: Boolean!
  updatedCount: Float!
}

enum MediaType {
  AUDIO
  GIF
  ICON
  IMAGE
  VIDEO
}

type Message {
  actions: [NotificationAction!]
  addDeleteAction: Boolean
  addMarkAsReadAction: Boolean
  addOpenNotificationAction: Boolean
  attachmentUuids: [String!]
  attachments: [MessageAttachment!]
  body: String
  bucket: Bucket!
  bucketId: String!
  collapseId: String
  createdAt: DateTime!
  deliveryType: NotificationDeliveryType!
  ephemeral: Boolean
  executionId: String
  externalSystemResponse: JSON
  fileAttachments: [Attachment!]
  groupId: String
  id: ID!
  locale: String
  maxReminders: Float
  postpones: [Float!]
  remindEveryMinutes: Float
  scheduledSendAt: DateTime
  snoozes: [Float!]
  sound: String
  subtitle: String
  tapAction: NotificationAction
  title: String!
  updatedAt: DateTime!
}

type MessageAttachment {
  attachmentUuid: String
  mediaType: MediaType!
  name: String
  saveOnServer: Boolean
  url: String
}

type MessageReminder {
  createdAt: DateTime!
  id: ID!
  maxReminders: Int!
  message: Message!
  messageId: ID!
  nextReminderAt: DateTime!
  remindEveryMinutes: Int!
  remindersSent: Int!
  updatedAt: DateTime!
  user: User!
  userId: ID!
}

input MobileAppleAuthDto {
  browser: String
  deviceName: String
  identityToken: String!
  osVersion: String
  payload: String!
  platform: String
}

type Mutation {
  adminCreateUser(input: AdminCreateUserInput!): User!
  adminDeleteUser(userId: String!): Boolean!
  appleConnectMobile(input: MobileAppleAuthDto!): Boolean!
  appleLoginMobile(input: MobileAppleAuthDto!): LoginResponse!
  approveSystemAccessTokenRequest(id: String!, input: ApproveSystemAccessTokenRequestDto): SystemAccessTokenRequest!
  """Batch update multiple server settings"""
  batchUpdateServerSettings(settings: [BatchUpdateSettingInput!]!): [ServerSetting!]!
  """Cancel all reminders for a message for the current user."""
  cancelMessageReminders(messageId: String!): Int!
  cancelPostpone(id: String!): Boolean!
  changePassword(input: ChangePasswordInput!): Boolean!
  cleanupExpiredPermissions: Float!
  confirmEmail(input: ConfirmEmailDto!): EmailConfirmationResponseDto!
  createAccessToken(input: CreateAccessTokenDto!): AccessTokenResponseDto!
  createAccessTokenForBucket(bucketId: String!, name: String!): AccessTokenResponseDto!
  createBucket(input: CreateBucketDto!): Bucket!
  """Create a new changelog (admin only)"""
  createChangelog(input: CreateChangelogInput!): Changelog!
  createExternalNotifySystem(input: CreateExternalNotifySystemDto!): ExternalNotifySystem!
  """Create a new invite code for a resource"""
  createInviteCode(input: CreateInviteCodeInput!): InviteCode!
  """
  Create a new message and send notifications to bucket users (returns the created message).
  """
  createMessage(input: CreateMessageDto!): Message!
  createOAuthProvider(input: CreateOAuthProviderDto!): OAuthProvider!
  createOrRegenerateWatchToken: AccessTokenResponseDto!
  createPayloadMapper(input: CreatePayloadMapperDto!): PayloadMapper!
  createSystemAccessTokenRequest(input: CreateSystemAccessTokenRequestDto!): SystemAccessTokenRequest!
  createSystemToken(description: String, expiresAt: String, maxCalls: Float!, requesterId: String, scopes: [String!]): SystemAccessTokenDto!
  createUserLog(input: CreateUserLogInput!): UserLog!
  """Create a new user template"""
  createUserTemplate(input: CreateUserTemplateDto!): UserTemplate!
  createWebhook(input: CreateWebhookDto!): UserWebhook!
  declineSystemAccessTokenRequest(id: String!, input: DeclineSystemAccessTokenRequestDto): SystemAccessTokenRequest!
  deleteAccount: Boolean!
  deleteAttachment(id: ID!): Boolean!
  """Delete a specific backup file"""
  deleteBackup(filename: String!): Boolean!
  deleteBucket(id: String!): Boolean!
  """Delete a changelog (admin only)"""
  deleteChangelog(id: ID!): Boolean!
  deleteExternalNotifySystem(id: ID!): Boolean!
  """Delete an invite code"""
  deleteInviteCode(id: String!): Boolean!
  deleteMagicCode(bucketId: String!): UserBucket!
  """
  Delete a message (user must have write on bucket). Returns true if deleted.
  """
  deleteMessage(id: String!): Boolean!
  deleteNotification(id: String!): Boolean!
  deleteOAuthProvider(id: String!): Boolean!
  deletePayloadMapper(id: String!): Boolean!
  deleteServerFile(name: String!, path: String): Boolean!
  """Delete user template by ID"""
  deleteUserTemplate(id: ID!): Boolean!
  deleteWatchToken: Boolean!
  deleteWebhook(id: ID!): Boolean!
  deviceReportNotificationReceived(id: String!): Notification!
  executeWebhook(id: ID!): Boolean!
  grantEntityPermission(input: GrantEntityPermissionInput!): EntityPermission!
  login(input: LoginDto!): LoginResponse!
  logout: String!
  markAllNotificationsAsRead: MarkAllAsReadResult!
  markNotificationAsRead(id: String!): Notification!
  markNotificationAsReceived(id: String!, userDeviceId: String!): Notification!
  markNotificationAsUnread(id: String!): Notification!
  massDeleteNotifications(ids: [String!]!): MassDeleteResult!
  massMarkNotificationsAsRead(ids: [String!]!): MassMarkResult!
  massMarkNotificationsAsUnread(ids: [String!]!): MassMarkResult!
  postponeNotification(input: PostponeNotificationDto!): PostponeResponseDto!
  """Redeem an invite code to gain access"""
  redeemInviteCode(input: RedeemInviteCodeInput!): InviteCodeRedemptionResult!
  refreshAccessToken(refreshToken: String!): RefreshTokenResponse!
  regenerateMagicCode(bucketId: String!): UserBucket!
  register(input: RegisterDto!): RegisterResponse!
  registerDevice(input: RegisterDeviceDto!): UserDevice!
  removeDevice(deviceId: String!): Boolean!
  removeDeviceByToken(deviceToken: String!): Boolean!
  requestEmailConfirmation(input: RequestEmailConfirmationDto!): EmailConfirmationResponseDto!
  requestPasswordReset(input: RequestPasswordResetDto!): PasswordResetResponseDto!
  resetPassword(input: ResetPasswordDto!): PasswordResetResponseDto!
  """Restart the server"""
  restartServer: String!
  revokeAccessToken(tokenId: String!): Boolean!
  revokeAllAccessTokens: Boolean!
  revokeAllOtherSessions: Boolean!
  revokeEntityPermission(input: RevokeEntityPermissionInput!): Boolean!
  revokeSession(sessionId: String!): Boolean!
  revokeSystemToken(id: String!): Boolean!
  setBucketSnooze(bucketId: String!, snoozeUntil: String): UserBucket! @deprecated(reason: "Usa Bucket.setBucketSnooze (questo sar√† rimosso)")
  setBucketSnoozeMinutes(bucketId: String!, input: SetBucketSnoozeMinutesInput!): UserBucket!
  setPassword(input: ChangePasswordInput!): Boolean!
  shareBucket(input: GrantEntityPermissionInput!): EntityPermission!
  shareExternalNotifySystem(input: GrantEntityPermissionInput!): EntityPermission!
  toggleOAuthProvider(id: String!): OAuthProvider!
  """Manually trigger a database backup"""
  triggerBackup: String!
  """Manually trigger log cleanup based on retention policy"""
  triggerLogCleanup: Boolean!
  unshareBucket(input: RevokeEntityPermissionInput!): Boolean!
  unshareExternalNotifySystem(input: RevokeEntityPermissionInput!): Boolean!
  updateAccessToken(input: UpdateAccessTokenDto!, tokenId: String!): AccessTokenListDto!
  updateBucket(id: String!, input: UpdateBucketDto!): Bucket!
  updateBucketSnoozes(bucketId: String!, snoozes: [SnoozeScheduleInput!]!): UserBucket! @deprecated(reason: "Usa future Bucket mutation (updateBucketSnoozes)")
  """Update an existing changelog (admin only)"""
  updateChangelog(input: UpdateChangelogInput!): Changelog!
  updateDeviceToken(input: UpdateDeviceTokenDto!): UserDevice!
  updateExternalNotifySystem(id: ID!, input: UpdateExternalNotifySystemDto!): ExternalNotifySystem!
  """Update an invite code"""
  updateInviteCode(input: UpdateInviteCodeInput!): InviteCode!
  """Update a message (e.g. scheduled send time)."""
  updateMessage(id: String!, input: UpdateMessageDto!): Message!
  updateOAuthProvider(id: String!, input: UpdateOAuthProviderDto!): OAuthProvider!
  updatePayloadMapper(id: String!, input: UpdatePayloadMapperDto!): PayloadMapper!
  updateProfile(input: UpdateProfileInput!): User!
  updateReceivedNotifications(id: String!): UpdateReceivedResult!
  """Update an existing server setting"""
  updateServerSetting(configType: ServerSettingType!, input: UpdateServerSettingDto!): ServerSetting!
  updateSystemToken(description: String, expiresAt: String, id: String!, maxCalls: Float, requesterId: String, scopes: [String!]): SystemAccessTokenDto!
  updateUserBucketCustomName(bucketId: String!, customName: String): UserBucket!
  updateUserDevice(input: UpdateUserDeviceInput!): UserDevice!
  updateUserRole(input: UpdateUserRoleInput!): User!
  """Update user template by ID"""
  updateUserTemplate(id: ID!, input: UpdateUserTemplateDto!): UserTemplate!
  updateWebhook(id: ID!, input: UpdateWebhookDto!): UserWebhook!
  upsertMyAdminSubscription(eventTypes: [String!]!): [String!]!
  upsertUserSetting(input: UpsertUserSettingInput!): UserSetting!
  validateResetToken(resetToken: String!): Boolean!
}

type Notification {
  createdAt: DateTime!
  error: String
  id: ID!
  message: Message!
  readAt: DateTime
  receivedAt: DateTime
  sentAt: DateTime
  updatedAt: DateTime!
  user: User!
  userDevice: UserDevice
  userDeviceId: String
  userId: String!
}

type NotificationAction {
  destructive: Boolean
  icon: String
  title: String
  type: NotificationActionType!
  value: String
}

input NotificationActionDto {
  destructive: Boolean
  icon: String
  title: String
  type: NotificationActionType!
  value: String
}

enum NotificationActionType {
  BACKGROUND_CALL
  DELETE
  MARK_AS_READ
  NAVIGATE
  OPEN_NOTIFICATION
  POSTPONE
  SNOOZE
  WEBHOOK
}

input NotificationAttachmentDto {
  attachmentUuid: String
  mediaType: MediaType!
  name: String
  saveOnServer: Boolean
  url: String
}

enum NotificationDeliveryType {
  CRITICAL
  NORMAL
  NO_PUSH
  SILENT
}

type NotificationPostpone {
  createdAt: DateTime!
  id: ID!
  message: Message!
  messageId: String!
  notification: Notification!
  notificationId: String!
  sendAt: DateTime!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type NotificationServiceInfo {
  devicePlatform: DevicePlatform!
  service: NotificationServiceType!
}

"""Type of notification service (Push or Local)"""
enum NotificationServiceType {
  LOCAL
  PUSH
}

type OAuthProvider {
  additionalConfig: String
  authorizationUrl: String
  callbackUrl: String
  clientId: String!
  clientSecret: String!
  color: String
  createdAt: DateTime!
  iconUrl: String
  id: ID!
  isEnabled: Boolean!
  name: String!
  profileFields: [String!]
  scopes: [String!]!
  textColor: String
  tokenUrl: String
  type: OAuthProviderType!
  updatedAt: DateTime!
  userInfoUrl: String
}

type OAuthProviderPublicDto {
  color: String
  iconUrl: String
  id: String!
  name: String!
  providerKey: String!
  textColor: String
  type: OAuthProviderType!
}

"""
Type of OAuth provider (GitHub, Google, Discord, Apple, Facebook, Microsoft, or custom)
"""
enum OAuthProviderType {
  APPLE
  APPLE_SIGNIN
  CUSTOM
  DISCORD
  FACEBOOK
  GITHUB
  GOOGLE
  LOCAL
  MICROSOFT
}

type PaginatedLogs {
  limit: Int!
  logs: [Log!]!
  page: Int!
  total: Int!
  totalPages: Int!
}

type PaginatedUserLogs {
  limit: Int!
  logs: [UserLogEntry!]!
  page: Int!
  total: Int!
  totalPages: Int!
}

type PasswordResetResponseDto {
  message: String!
  success: Boolean!
}

type PayloadMapper {
  builtInName: PayloadMapperBuiltInType
  createdAt: DateTime!
  id: ID!
  jsEvalFn: String!
  name: String!
  requiredUserSettings: [UserSettingType!]
  updatedAt: DateTime!
  user: User
  userId: ID
}

"""Built-in payload mapper types"""
enum PayloadMapperBuiltInType {
  ZENTIK_ATLAS_STATUSPAGE
  ZENTIK_AUTHENTIK
  ZENTIK_EMQX
  ZENTIK_EXPO
  ZENTIK_GITHUB
  ZENTIK_INSTATUS
  ZENTIK_RAILWAY
  ZENTIK_SERVARR
  ZENTIK_STATUS_IO
}

"""Permission enum for bucket access"""
enum Permission {
  ADMIN
  DELETE
  READ
  WRITE
}

input PostponeNotificationDto {
  minutes: Int!
  notificationId: String!
}

type PostponeResponseDto {
  createdAt: DateTime!
  id: String!
  notificationId: String!
  sendAt: DateTime!
}

type PublicAppConfig {
  emailEnabled: Boolean!
  iconUploaderEnabled: Boolean!
  localRegistrationEnabled: Boolean!
  oauthProviders: [OAuthProviderPublicDto!]!
  socialLoginEnabled: Boolean!
  socialRegistrationEnabled: Boolean!
  systemTokenRequestsEnabled: Boolean!
  uploadEnabled: Boolean!
}

type Query {
  """List all changelogs (admin, includes inactive)"""
  adminChangelogs: [Changelog!]!
  allOAuthProviders: [OAuthProvider!]!
  allServerFiles(path: String): [FileInfoWithPathDto!]!
  attachment(id: ID!): Attachment!
  bucket(id: String!): Bucket!
  bucketPermissions(bucketId: String!): [EntityPermission!]!
  buckets: [Bucket!]!
  """Get a specific changelog by id (public)"""
  changelog(id: ID!): Changelog!
  """List all changelogs (public)"""
  changelogs: [Changelog!]!
  checkEmailStatus(email: String!): EmailStatusResponseDto!
  enabledOAuthProviders: [OAuthProviderPublicDto!]!
  entityExecution(id: String!): EntityExecution
  events(query: EventsQueryDto!): EventsResponseDto!
  externalNotifySystem(id: ID!): ExternalNotifySystem!
  externalNotifySystemPermissions(resourceId: String!): [EntityPermission!]!
  externalNotifySystems: [ExternalNotifySystem!]!
  getAccessToken(tokenId: String!): AccessTokenListDto!
  getAccessTokensForBucket(bucketId: String!): [AccessTokenListDto!]!
  getBackendVersion: String!
  """Get the download URL for a specific backup file"""
  getBackupDownloadUrl(filename: String!): String!
  getEntityExecutions(input: GetEntityExecutionsInput!): [EntityExecution!]!
  getResourcePermissions(input: GetResourcePermissionsInput!): [EntityPermission!]!
  getSystemToken(id: String!): SystemAccessTokenDto
  getUserAccessTokens: [AccessTokenListDto!]!
  getUserSessions: [SessionInfoDto!]!
  getWatchToken: AccessTokenListDto
  healthcheck: String!
  """Get invite code by ID"""
  inviteCode(id: String!): InviteCode!
  """Get invite codes for a resource"""
  inviteCodesForResource(resourceId: String!, resourceType: String!): [InviteCode!]!
  """List all available database backups"""
  listBackups: [BackupInfoDto!]!
  listSystemTokens: [SystemAccessTokenDto!]!
  """Get logs with pagination and filtering"""
  logs(input: GetLogsInput!): PaginatedLogs!
  me: User!
  messageAttachments(messageId: ID!): [Attachment!]!
  """Active message reminders (retry) for the current user."""
  messageRemindersForCurrentUser: [MessageReminder!]!
  myAdminSubscription: [String!]
  mySystemAccessTokenRequests: [SystemAccessTokenRequest!]!
  notification(id: String!): Notification!
  notificationServices: [NotificationServiceInfo!]!
  notifications: [Notification!]!
  oauthProvider(id: String!): OAuthProvider!
  payloadMapper(id: String!): PayloadMapper!
  payloadMappers: [PayloadMapper!]!
  pendingPostpones: [NotificationPostpone!]!
  publicAppConfig: PublicAppConfig!
  """
  Messages with scheduled send in the future (user must have write on bucket).
  """
  scheduledMessagesForCurrentUser: [Message!]!
  serverFiles(path: String): [FileInfoDto!]!
  """Get a specific server setting by type"""
  serverSetting(configType: ServerSettingType!): ServerSetting
  """Get all server settings"""
  serverSettings: [ServerSetting!]!
  systemAccessTokenRequests: [SystemAccessTokenRequest!]!
  """Get total log count"""
  totalLogCount: Float!
  user(id: String!): User!
  userAttachments(userId: ID!): [Attachment!]!
  userDevice: UserDevice
  userDevices: [UserDevice!]!
  """Get user logs with pagination and filtering"""
  userLogs(input: GetUserLogsInput!): PaginatedUserLogs!
  userNotificationStats(userId: String): UserNotificationStats!
  userSettings(deviceId: String): [UserSetting!]!
  """Get user template by ID"""
  userTemplate(id: ID!): UserTemplate!
  """Get all user templates for the authenticated user"""
  userTemplates: [UserTemplate!]!
  userWebhooks: [UserWebhook!]!
  users: [User!]!
  webhook(id: ID!): UserWebhook!
}

input RedeemInviteCodeInput {
  """Invite code to redeem"""
  code: String!
}

type RefreshTokenResponse {
  accessToken: String!
  message: String
  refreshToken: String!
}

input RegisterDeviceDto {
  deviceId: String
  deviceModel: String
  deviceName: String
  deviceToken: String
  """
  Optional JSON-serialized metadata for the device (app versions, build info, etc.)
  """
  metadata: String
  onlyLocal: Boolean
  osVersion: String
  platform: DevicePlatform!
  publicKey: String
  subscriptionFields: WebPushSubscriptionFieldsInput
}

input RegisterDto {
  email: String!
  firstName: String
  lastName: String
  locale: String
  password: String!
  username: String!
}

type RegisterResponse {
  accessToken: String
  emailConfirmationRequired: Boolean!
  message: String!
  refreshToken: String
  user: User!
}

input RequestEmailConfirmationDto {
  email: String!
  locale: String
}

input RequestPasswordResetDto {
  email: String!
  locale: String
}

input ResetPasswordDto {
  newPassword: String!
  resetToken: String!
}

type ResourcePermissionsDto {
  """User can administer (share) this resource"""
  canAdmin: Boolean!
  """User can delete this resource"""
  canDelete: Boolean!
  """User can read this resource"""
  canRead: Boolean!
  """User can write/update this resource"""
  canWrite: Boolean!
  """User is the owner of this resource"""
  isOwner: Boolean!
  """Resource is shared with this user"""
  isSharedWithMe: Boolean!
  """Number of users this resource is shared with"""
  sharedCount: Int!
}

"""Type of resource for permissions"""
enum ResourceType {
  BUCKET
  EXTERNAL_NOTIFY_SYSTEM
  USER_WEBHOOK
}

input RevokeEntityPermissionInput {
  resourceId: String!
  resourceType: ResourceType!
  userEmail: String
  userId: String
  username: String
}

type ServerSetting {
  configType: ServerSettingType!
  createdAt: DateTime!
  id: ID!
  """Possible values for the setting (for enum-like settings)"""
  possibleValues: [String!]
  updatedAt: DateTime!
  """Boolean value for the setting, when applicable"""
  valueBool: Boolean
  """Numeric value for the setting, when applicable"""
  valueNumber: Float
  """String value for the setting, when applicable"""
  valueText: String
}

enum ServerSettingType {
  ApnBundleId
  ApnKeyId
  ApnPrivateKeyPath
  ApnProduction
  ApnPush
  ApnTeamId
  AttachmentsAllowedMimeTypes
  AttachmentsDeleteJobEnabled
  AttachmentsEnabled
  AttachmentsMaxAge
  AttachmentsMaxFileSize
  AttachmentsStoragePath
  BackupCronJob
  BackupEnabled
  BackupExecuteOnStart
  BackupMaxToKeep
  BackupStoragePath
  ChangelogRemoteServer
  CorsCredentials
  CorsOrigin
  EmailEnabled
  EmailFrom
  EmailFromName
  EmailHost
  EmailPass
  EmailPort
  EmailSecure
  EmailType
  EmailUser
  EnableSystemTokenRequests
  FirebaseClientEmail
  FirebasePrivateKey
  FirebaseProjectId
  FirebasePush
  IconUploaderEnabled
  JwtAccessTokenExpiration
  JwtRefreshSecret
  JwtRefreshTokenExpiration
  JwtSecret
  LocalRegistrationEnabled
  LogLevel
  LogRetentionDays
  LogStorageDirectory
  MessagesDeleteJobEnabled
  MessagesMaxAge
  PrometheusEnabled
  PushNotificationsPassthroughServer
  PushPassthroughToken
  RateLimitBlockMs
  RateLimitForwardHeader
  RateLimitLimit
  RateLimitMessagesRps
  RateLimitMessagesTtlMs
  RateLimitTrustProxyEnabled
  RateLimitTtlMs
  ResendApiKey
  ServerFilesDirectory
  ServerStableIdentifier
  SocialLoginEnabled
  SocialRegistrationEnabled
  StoreLogsOnFs
  SystemTokenUsageStats
  VapidSubject
  WebPush
}

type SessionInfoDto {
  browser: String
  createdAt: DateTime!
  deviceName: String
  expiresAt: DateTime!
  id: ID!
  ipAddress: String
  isActive: Boolean!
  isCurrent: Boolean!
  lastActivity: DateTime!
  location: String
  loginProvider: OAuthProviderType
  operatingSystem: String
}

input SetBucketSnoozeMinutesInput {
  minutes: Float!
}

type SnoozeSchedule {
  days: [String!]!
  isEnabled: Boolean!
  timeFrom: String!
  timeTill: String!
}

input SnoozeScheduleInput {
  days: [String!]!
  isEnabled: Boolean!
  timeFrom: String!
  timeTill: String!
}

type Subscription {
  bucketCreated: Bucket!
  bucketDeleted: String!
  bucketUpdated: Bucket!
  entityPermissionUpdated(bucketId: String): EntityPermission!
  notificationCreated: Notification!
  notificationDeleted: String!
  notificationUpdated: Notification!
  userBucketUpdated(bucketId: String): UserBucket!
  userPasswordChanged: Boolean!
  userProfileUpdated: User!
}

type SystemAccessToken {
  calls: Float!
  createdAt: DateTime!
  description: String
  expiresAt: DateTime
  failedCalls: Float!
  id: String!
  lastResetAt: DateTime
  maxCalls: Float!
  requester: User
  requesterId: String
  requesterIdentifier: String
  scopes: [String!]
  token: String
  tokenHash: String!
  totalCalls: Float!
  totalFailedCalls: Float!
  updatedAt: DateTime!
}

type SystemAccessTokenDto {
  calls: Float!
  createdAt: DateTime!
  description: String
  expiresAt: DateTime
  failedCalls: Float!
  id: String!
  lastResetAt: DateTime
  maxCalls: Float!
  rawToken: String
  requester: User
  scopes: [String!]
  token: String
  totalCalls: Float!
  totalFailedCalls: Float!
  updatedAt: DateTime!
}

type SystemAccessTokenRequest {
  createdAt: DateTime!
  description: String
  id: String!
  maxRequests: Float!
  plainTextToken: String
  status: SystemAccessTokenRequestStatus!
  systemAccessToken: SystemAccessToken
  systemAccessTokenId: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

"""Status of a system access token request"""
enum SystemAccessTokenRequestStatus {
  APPROVED
  DECLINED
  PENDING
}

input UpdateAccessTokenDto {
  expiresAt: DateTime
  name: String!
  scopes: [String!]
}

input UpdateBucketDto {
  color: String
  description: String
  externalNotifySystemId: String
  externalSystemChannel: String
  generateIconWithInitials: Boolean
  icon: String
  isProtected: Boolean
  isPublic: Boolean
  name: String
  preset: String
}

input UpdateChangelogInput {
  active: Boolean
  androidVersion: String
  backendVersion: String
  description: String
  entries: [ChangelogEntryInput!]
  id: ID!
  iosVersion: String
  uiVersion: String
}

input UpdateDeviceTokenDto {
  newDeviceToken: String!
  oldDeviceToken: String!
}

input UpdateExternalNotifySystemDto {
  authPassword: String
  authToken: String
  authUser: String
  baseUrl: String
  color: String
  iconUrl: String
  name: String
  type: ExternalNotifySystemType
}

input UpdateInviteCodeInput {
  """Expiration date (ISO string)"""
  expiresAt: String
  """Invite code ID"""
  id: String!
  """Maximum number of uses"""
  maxUses: Int
  """Permissions to grant"""
  permissions: [String!]
}

input UpdateMessageDto {
  scheduledSendAt: DateTime
}

input UpdateOAuthProviderDto {
  additionalConfig: String
  authorizationUrl: String
  callbackUrl: String
  clientId: String
  clientSecret: String
  color: String
  iconUrl: String
  isEnabled: Boolean
  name: String
  profileFields: [String!]
  scopes: [String!]
  textColor: String
  tokenUrl: String
  type: OAuthProviderType
  userInfoUrl: String
}

input UpdatePayloadMapperDto {
  jsEvalFn: String
  name: String
  requiredUserSettings: [UserSettingType!]
}

input UpdateProfileInput {
  avatar: String
  firstName: String
  lastName: String
}

type UpdateReceivedResult {
  success: Boolean!
  updatedCount: Float!
}

input UpdateServerSettingDto {
  valueBool: Boolean
  valueNumber: Float
  valueText: String
}

input UpdateUserDeviceInput {
  deviceId: String!
  deviceModel: String
  deviceName: String
  deviceToken: String
  """
  Optional JSON-serialized metadata for the device (app versions, build info, etc.)
  """
  metadata: String
  osVersion: String
  subscriptionFields: WebPushSubscriptionFieldsInput
}

input UpdateUserRoleInput {
  role: UserRole!
  userId: String!
}

input UpdateUserTemplateDto {
  body: String
  description: String
  name: String
  subtitle: String
  title: String
}

input UpdateWebhookDto {
  body: JSON
  headers: [WebhookHeaderDto!]
  method: HttpMethod
  name: String
  url: String
}

input UpsertUserSettingInput {
  configType: UserSettingType!
  deviceId: String
  valueBool: Boolean
  valueText: String
}

type User {
  accessTokens: [UserAccessToken!]
  avatar: String
  buckets: [Bucket!]
  createdAt: DateTime!
  devices: [UserDevice!]
  email: String!
  emailConfirmationToken: String
  emailConfirmationTokenRequestedAt: DateTime
  emailConfirmed: Boolean!
  externalNotifySystems: [ExternalNotifySystem!]
  firstName: String
  hasPassword: Boolean!
  id: ID!
  identities: [UserIdentity!]
  lastName: String
  resetToken: String
  resetTokenRequestedAt: DateTime
  role: UserRole!
  sessions: [UserSession!]
  templates: [UserTemplate!]
  updatedAt: DateTime!
  userBuckets: [UserBucket!]
  username: String!
  webhooks: [UserWebhook!]
}

type UserAccessToken {
  createdAt: DateTime!
  expiresAt: DateTime
  id: String!
  isExpired: Boolean!
  lastUsed: DateTime
  name: String!
  scopes: [String!]
  token: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type UserBucket {
  bucket: Bucket!
  bucketId: String!
  createdAt: DateTime!
  customName: String
  id: ID!
  magicCode: String
  snoozeUntil: DateTime
  snoozes: [SnoozeSchedule!]
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type UserDevice {
  createdAt: DateTime!
  deviceModel: String
  deviceName: String
  deviceToken: String
  id: ID!
  lastUsed: DateTime!
  """
  Optional JSON-serialized metadata for the device (app versions, build info, etc.)
  """
  metadata: String
  onlyLocal: Boolean!
  osVersion: String
  platform: String!
  privateKey: String
  publicKey: String
  subscriptionFields: WebPushSubscriptionFields
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type UserIdentity {
  avatarUrl: String
  createdAt: DateTime!
  email: String
  id: ID!
  metadata: String
  providerType: OAuthProviderType
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type UserLog {
  createdAt: DateTime!
  id: String!
  payload: JSON!
  type: UserLogType!
  userId: String
}

type UserLogEntry {
  createdAt: DateTime!
  id: ID!
  payload: JSON!
  type: UserLogType!
  userId: String
}

"""Type of user log entry"""
enum UserLogType {
  APP_LOG
  FEEDBACK
}

type UserNotificationStats {
  last7Days: Float!
  last7DaysAcked: Float!
  last30Days: Float!
  last30DaysAcked: Float!
  thisMonth: Float!
  thisMonthAcked: Float!
  thisWeek: Float!
  thisWeekAcked: Float!
  today: Float!
  todayAcked: Float!
  total: Float!
  totalAcked: Float!
}

"""User role enum"""
enum UserRole {
  ADMIN
  MODERATOR
  USER
}

type UserSession {
  browser: String
  createdAt: DateTime!
  deviceName: String
  exchangeCode: String
  exchangeCodeRequestedAt: DateTime
  expiresAt: DateTime!
  id: ID!
  ipAddress: String
  isActive: Boolean!
  lastActivity: DateTime
  loginProvider: OAuthProviderType
  operatingSystem: String
  tokenId: String!
  updatedAt: DateTime!
  user: User!
  userAgent: String
  userId: String!
}

type UserSetting {
  configType: UserSettingType!
  createdAt: DateTime!
  device: UserDevice
  deviceId: String
  id: ID!
  updatedAt: DateTime!
  user: User!
  userId: String!
  """Boolean value for the setting, when applicable"""
  valueBool: Boolean
  """String value for the setting, when applicable"""
  valueText: String
}

enum UserSettingType {
  AutoAddDeleteAction
  AutoAddMarkAsReadAction
  AutoAddOpenNotificationAction
  DefaultPostpones
  DefaultSnoozes
  DisableUserTracking
  ExpoKey
  GithubEventsFilter
  HomeassistantToken
  HomeassistantUrl
  Language
  ServerStableIdentifier
  Timezone
  UnencryptOnBigPayload
}

type UserTemplate {
  body: String!
  createdAt: DateTime!
  description: String
  id: ID!
  input: String
  name: String!
  output: String
  subtitle: String
  title: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type UserWebhook {
  body: JSON
  createdAt: DateTime!
  headers: [WebhookHeader!]!
  id: ID!
  method: HttpMethod!
  name: String!
  updatedAt: DateTime!
  url: String!
  user: User!
}

type WebPushSubscriptionFields {
  auth: String
  endpoint: String
  p256dh: String
}

input WebPushSubscriptionFieldsInput {
  auth: String
  endpoint: String
  p256dh: String
}

type WebhookHeader {
  key: String!
  value: String!
}

input WebhookHeaderDto {
  key: String!
  value: String!
}