schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type AccessTokenListDto {
  createdAt: DateTime!
  expiresAt: DateTime
  id: String!
  isExpired: Boolean!
  lastUsed: DateTime
  name: String!
  scopes: [String!]
  token: String
}

type AccessTokenResponseDto {
  createdAt: DateTime!
  expiresAt: DateTime
  id: String!
  name: String!
  token: String!
  tokenStored: Boolean!
}

input ApproveSystemAccessTokenRequestDto {
  expiresAt: String
}

type Attachment {
  createdAt: DateTime!
  filename: String!
  filepath: String!
  id: ID!
  mediaType: MediaType
  messageId: String
  originalFilename: String
  size: Float
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type BackupInfoDto {
  createdAt: DateTime!
  filename: String!
  path: String!
  size: String!
  sizeBytes: Float!
}

input BatchUpdateSettingInput {
  configType: ServerSettingType!
  valueBool: Boolean
  valueNumber: Float
  valueText: String
}

type Bucket {
  color: String
  createdAt: DateTime!
  description: String
  icon: String
  iconAttachmentUuid: String
  id: ID!
  isAdmin: Boolean
  isProtected: Boolean
  isPublic: Boolean
  messages: [Message!]
  name: String!
  permissions: [EntityPermission!]!
  updatedAt: DateTime!
  user: User!
  userBucket: UserBucket
  userBuckets: [UserBucket!]
  userPermissions: BucketPermissionsDto!
}

type BucketPermissionsDto {
  """User can administer this bucket"""
  canAdmin: Boolean!
  """User can delete this bucket"""
  canDelete: Boolean!
  """User can read from this bucket"""
  canRead: Boolean!
  """User can write to this bucket"""
  canWrite: Boolean!
  """User is the owner of this bucket"""
  isOwner: Boolean!
  """Bucket is shared with this user"""
  isSharedWithMe: Boolean!
  """Number of users this bucket is shared with"""
  sharedCount: Int!
}

input ChangePasswordInput {
  currentPassword: String!
  newPassword: String!
}

input ConfirmEmailDto {
  code: String!
  locale: String
}

input CreateAccessTokenDto {
  expiresAt: DateTime
  name: String!
  scopes: [String!]
  storeToken: Boolean
}

input CreateBucketDto {
  color: String
  description: String
  generateIconWithInitials: Boolean
  icon: String
  isProtected: Boolean
  isPublic: Boolean
  name: String!
}

input CreateInviteCodeInput {
  """Expiration date (ISO string)"""
  expiresAt: String
  """Maximum number of uses"""
  maxUses: Int
  """Permissions to grant"""
  permissions: [String!]!
  """Resource ID"""
  resourceId: String!
  """Resource type"""
  resourceType: String!
}

input CreateMessageDto {
  actions: [NotificationActionDto!]
  addDeleteAction: Boolean = true
  addMarkAsReadAction: Boolean = true
  addOpenNotificationAction: Boolean
  attachmentUuids: [String!]
  attachments: [NotificationAttachmentDto!]
  body: String
  bucketId: String!
  collapseId: String
  deliveryType: NotificationDeliveryType!
  executionId: String
  gifUrl: String
  groupId: String
  imageUrl: String
  locale: String
  maxReminders: Float
  postpones: [Float!]
  remindEveryMinutes: Float
  snoozes: [Float!]
  sound: String
  subtitle: String
  tapAction: NotificationActionDto
  tapUrl: String
  title: String!
  userIds: [String!]
  videoUrl: String
}

input CreateOAuthProviderDto {
  additionalConfig: String
  authorizationUrl: String
  callbackUrl: String
  clientId: String!
  clientSecret: String!
  color: String
  iconUrl: String
  isEnabled: Boolean
  name: String!
  profileFields: [String!]
  scopes: [String!]!
  textColor: String
  tokenUrl: String
  type: OAuthProviderType!
  userInfoUrl: String
}

input CreatePayloadMapperDto {
  jsEvalFn: String!
  name: String!
  requiredUserSettings: [UserSettingType!]
  userId: String
}

input CreateSystemAccessTokenRequestDto {
  description: String
  maxRequests: Int!
}

input CreateWebhookDto {
  body: JSON
  headers: [WebhookHeaderDto!]!
  method: HttpMethod!
  name: String!
  url: String!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DeclineSystemAccessTokenRequestDto {
  reason: String
}

input DeviceInfoDto {
  deviceModel: String
  deviceName: String
  osVersion: String
  platform: String
}

"""Platform types for devices"""
enum DevicePlatform {
  ANDROID
  IOS
  WEB
}

type EmailConfirmationResponseDto {
  message: String!
  success: Boolean!
}

type EmailStatusResponseDto {
  confirmed: Boolean!
  message: String!
}

type EntityExecution {
  createdAt: DateTime!
  durationMs: Float
  entityId: String
  entityName: String
  errors: String
  id: ID!
  input: String!
  output: String
  status: ExecutionStatus!
  type: ExecutionType!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type EntityPermission {
  createdAt: DateTime!
  expiresAt: DateTime
  grantedBy: User
  id: ID!
  """Invite code ID used to create this permission"""
  inviteCodeId: String
  permissions: [Permission!]!
  resourceId: String!
  resourceType: String!
  updatedAt: DateTime!
  user: User!
}

type Event {
  createdAt: DateTime!
  id: String!
  objectId: String
  targetId: String
  type: EventType!
  userId: String
}

"""Tracked event type"""
enum EventType {
  ACCOUNT_DELETE
  BUCKET_CREATION
  BUCKET_SHARING
  BUCKET_UNSHARING
  DEVICE_REGISTER
  DEVICE_UNREGISTER
  LOGIN
  LOGIN_OAUTH
  LOGOUT
  MESSAGE
  NOTIFICATION
  NOTIFICATION_ACK
  PUSH_PASSTHROUGH
  REGISTER
  SYSTEM_TOKEN_REQUEST_APPROVED
  SYSTEM_TOKEN_REQUEST_CREATED
  SYSTEM_TOKEN_REQUEST_DECLINED
}

input EventsQueryDto {
  limit: Int = 20
  objectId: String
  page: Int = 1
  targetId: String
  type: EventType
  userId: String
}

type EventsResponseDto {
  events: [Event!]!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  limit: Int!
  page: Int!
  total: Int!
  totalPages: Int!
}

"""Status of the execution"""
enum ExecutionStatus {
  ERROR
  SKIPPED
  SUCCESS
  TIMEOUT
}

"""Types of executions that are tracked"""
enum ExecutionType {
  PAYLOAD_MAPPER
  WEBHOOK
}

type FileInfoDto {
  isDir: Boolean!
  mtime: DateTime!
  name: String!
  size: Float!
}

input GetEntityExecutionsInput {
  entityId: String
  entityName: String
  type: ExecutionType
  userId: String
}

input GetLogsInput {
  context: String
  level: LogLevel
  limit: Int = 50
  page: Int = 1
  search: String
}

input GetResourcePermissionsInput {
  resourceId: String!
  resourceType: ResourceType!
}

input GrantEntityPermissionInput {
  expiresAt: String
  permissions: [Permission!]!
  resourceId: String!
  resourceType: ResourceType!
  userEmail: String
  userId: String
  username: String
}

"""HTTP methods for webhooks"""
enum HttpMethod {
  DELETE
  GET
  PATCH
  POST
  PUT
}

type InviteCode {
  """Unique invite code"""
  code: String!
  createdAt: DateTime!
  """User who created this code"""
  createdBy: String!
  creator: User!
  """Expiration date for this code"""
  expiresAt: String
  id: String!
  """Maximum number of uses (null = unlimited)"""
  maxUses: Float
  """Permissions granted by this code"""
  permissions: [String!]!
  """Resource ID this code grants access to"""
  resourceId: String!
  """Resource type (BUCKET, etc.)"""
  resourceType: String!
  updatedAt: DateTime!
  """Number of times this code has been used"""
  usageCount: Float!
}

type InviteCodeRedemptionResult {
  """Error message if redemption failed"""
  error: String
  """Permissions that were granted"""
  permissions: [String!]
  """Resource ID that was granted access to"""
  resourceId: String
  """Resource type that was granted access to"""
  resourceType: String
  """Whether redemption was successful"""
  success: Boolean!
}

"""JSON custom scalar type"""
scalar JSON

type Log {
  context: String
  createdAt: DateTime!
  id: ID!
  level: LogLevel!
  message: String!
  metadata: JSON
  timestamp: DateTime!
  trace: String
}

"""Log level enum"""
enum LogLevel {
  DEBUG
  ERROR
  HTTP
  INFO
  SILLY
  VERBOSE
  WARN
}

input LoginDto {
  deviceInfo: DeviceInfoDto
  email: String
  password: String!
  username: String
}

type LoginResponse {
  accessToken: String!
  message: String
  refreshToken: String!
  user: User!
}

type MarkAllAsReadResult {
  success: Boolean!
  updatedCount: Float!
}

type MassDeleteResult {
  deletedCount: Float!
  success: Boolean!
}

type MassMarkResult {
  success: Boolean!
  updatedCount: Float!
}

enum MediaType {
  AUDIO
  GIF
  ICON
  IMAGE
  VIDEO
}

type Message {
  actions: [NotificationAction!]
  addDeleteAction: Boolean
  addMarkAsReadAction: Boolean
  addOpenNotificationAction: Boolean
  attachmentUuids: [String!]
  attachments: [MessageAttachment!]
  body: String
  bucket: Bucket!
  bucketId: String!
  collapseId: String
  createdAt: DateTime!
  deliveryType: NotificationDeliveryType!
  executionId: String
  fileAttachments: [Attachment!]
  groupId: String
  id: ID!
  locale: String
  maxReminders: Float
  postpones: [Float!]
  remindEveryMinutes: Float
  snoozes: [Float!]
  sound: String
  subtitle: String
  tapAction: NotificationAction
  title: String!
  updatedAt: DateTime!
}

type MessageAttachment {
  attachmentUuid: String
  mediaType: MediaType!
  name: String
  saveOnServer: Boolean
  url: String
}

input MobileAppleAuthDto {
  browser: String
  deviceName: String
  identityToken: String!
  osVersion: String
  payload: String!
  platform: String
}

type Mutation {
  appleConnectMobile(input: MobileAppleAuthDto!): Boolean!
  appleLoginMobile(input: MobileAppleAuthDto!): LoginResponse!
  approveSystemAccessTokenRequest(id: String!, input: ApproveSystemAccessTokenRequestDto): SystemAccessTokenRequest!
  """Batch update multiple server settings"""
  batchUpdateServerSettings(settings: [BatchUpdateSettingInput!]!): [ServerSetting!]!
  cancelPostpone(id: String!): Boolean!
  changePassword(input: ChangePasswordInput!): Boolean!
  cleanupExpiredPermissions: Float!
  confirmEmail(input: ConfirmEmailDto!): EmailConfirmationResponseDto!
  createAccessToken(input: CreateAccessTokenDto!): AccessTokenResponseDto!
  createAccessTokenForBucket(bucketId: String!, name: String!): AccessTokenResponseDto!
  createBucket(input: CreateBucketDto!): Bucket!
  """Create a new invite code for a resource"""
  createInviteCode(input: CreateInviteCodeInput!): InviteCode!
  """
  Create a new message and send notifications to bucket users (returns the created message).
  """
  createMessage(input: CreateMessageDto!): Message!
  createOAuthProvider(input: CreateOAuthProviderDto!): OAuthProvider!
  createPayloadMapper(input: CreatePayloadMapperDto!): PayloadMapper!
  createSystemAccessTokenRequest(input: CreateSystemAccessTokenRequestDto!): SystemAccessTokenRequest!
  createSystemToken(description: String, expiresAt: String, maxCalls: Float!, requesterId: String, scopes: [String!]): SystemAccessTokenDto!
  createWebhook(input: CreateWebhookDto!): UserWebhook!
  declineSystemAccessTokenRequest(id: String!, input: DeclineSystemAccessTokenRequestDto): SystemAccessTokenRequest!
  deleteAccount: Boolean!
  """Delete a specific backup file"""
  deleteBackup(filename: String!): Boolean!
  deleteBucket(id: String!): Boolean!
  """Delete an invite code"""
  deleteInviteCode(id: String!): Boolean!
  deleteNotification(id: String!): Boolean!
  deleteOAuthProvider(id: String!): Boolean!
  deletePayloadMapper(id: String!): Boolean!
  deleteServerFile(name: String!, path: String): Boolean!
  deleteWebhook(id: ID!): Boolean!
  deviceReportNotificationReceived(id: String!): Notification!
  executeWebhook(id: ID!): Boolean!
  grantEntityPermission(input: GrantEntityPermissionInput!): EntityPermission!
  login(input: LoginDto!): LoginResponse!
  logout: String!
  markAllNotificationsAsRead: MarkAllAsReadResult!
  markNotificationAsRead(id: String!): Notification!
  markNotificationAsReceived(id: String!, userDeviceId: String!): Notification!
  markNotificationAsUnread(id: String!): Notification!
  massDeleteNotifications(ids: [String!]!): MassDeleteResult!
  massMarkNotificationsAsRead(ids: [String!]!): MassMarkResult!
  massMarkNotificationsAsUnread(ids: [String!]!): MassMarkResult!
  postponeNotification(input: PostponeNotificationDto!): PostponeResponseDto!
  """Redeem an invite code to gain access"""
  redeemInviteCode(input: RedeemInviteCodeInput!): InviteCodeRedemptionResult!
  refreshAccessToken(refreshToken: String!): RefreshTokenResponse!
  regenerateMagicCode(bucketId: String!): UserBucket!
  register(input: RegisterDto!): RegisterResponse!
  registerDevice(input: RegisterDeviceDto!): UserDevice!
  removeDevice(deviceId: String!): Boolean!
  removeDeviceByToken(deviceToken: String!): Boolean!
  requestEmailConfirmation(input: RequestEmailConfirmationDto!): EmailConfirmationResponseDto!
  requestPasswordReset(input: RequestPasswordResetDto!): PasswordResetResponseDto!
  resetPassword(input: ResetPasswordDto!): PasswordResetResponseDto!
  """Restart the server"""
  restartServer: String!
  revokeAccessToken(tokenId: String!): Boolean!
  revokeAllAccessTokens: Boolean!
  revokeAllOtherSessions: Boolean!
  revokeEntityPermission(input: RevokeEntityPermissionInput!): Boolean!
  revokeSession(sessionId: String!): Boolean!
  revokeSystemToken(id: String!): Boolean!
  setBucketSnooze(bucketId: String!, snoozeUntil: String): UserBucket! @deprecated(reason: "Usa Bucket.setBucketSnooze (questo sar√† rimosso)")
  setBucketSnoozeMinutes(bucketId: String!, input: SetBucketSnoozeMinutesInput!): UserBucket!
  setPassword(input: ChangePasswordInput!): Boolean!
  shareBucket(input: GrantEntityPermissionInput!): EntityPermission!
  toggleOAuthProvider(id: String!): OAuthProvider!
  """Manually trigger a database backup"""
  triggerBackup: String!
  """Manually trigger log cleanup based on retention policy"""
  triggerLogCleanup: Boolean!
  unshareBucket(input: RevokeEntityPermissionInput!): Boolean!
  updateAccessToken(input: UpdateAccessTokenDto!, tokenId: String!): AccessTokenListDto!
  updateBucket(id: String!, input: UpdateBucketDto!): Bucket!
  updateBucketSnoozes(bucketId: String!, snoozes: [SnoozeScheduleInput!]!): UserBucket! @deprecated(reason: "Usa future Bucket mutation (updateBucketSnoozes)")
  updateDeviceToken(input: UpdateDeviceTokenDto!): UserDevice!
  """Update an invite code"""
  updateInviteCode(input: UpdateInviteCodeInput!): InviteCode!
  updateOAuthProvider(id: String!, input: UpdateOAuthProviderDto!): OAuthProvider!
  updatePayloadMapper(id: String!, input: UpdatePayloadMapperDto!): PayloadMapper!
  updateProfile(input: UpdateProfileInput!): User!
  updateReceivedNotifications(id: String!): UpdateReceivedResult!
  """Update an existing server setting"""
  updateServerSetting(configType: ServerSettingType!, input: UpdateServerSettingDto!): ServerSetting!
  updateSystemToken(description: String, expiresAt: String, id: String!, maxCalls: Float, requesterId: String, scopes: [String!]): SystemAccessTokenDto!
  updateUserDevice(input: UpdateUserDeviceInput!): UserDevice!
  updateUserRole(input: UpdateUserRoleInput!): User!
  updateWebhook(id: ID!, input: UpdateWebhookDto!): UserWebhook!
  upsertMyAdminSubscription(eventTypes: [String!]!): [String!]!
  upsertUserSetting(input: UpsertUserSettingInput!): UserSetting!
  validateResetToken(resetToken: String!): Boolean!
}

type Notification {
  createdAt: DateTime!
  error: String
  id: ID!
  message: Message!
  readAt: DateTime
  receivedAt: DateTime
  sentAt: DateTime
  updatedAt: DateTime!
  user: User!
  userDevice: UserDevice
  userDeviceId: String
  userId: String!
}

type NotificationAction {
  destructive: Boolean
  icon: String
  title: String
  type: NotificationActionType!
  value: String
}

input NotificationActionDto {
  destructive: Boolean
  icon: String
  title: String
  type: NotificationActionType!
  value: String
}

enum NotificationActionType {
  BACKGROUND_CALL
  DELETE
  MARK_AS_READ
  NAVIGATE
  OPEN_NOTIFICATION
  POSTPONE
  SNOOZE
  WEBHOOK
}

input NotificationAttachmentDto {
  attachmentUuid: String
  mediaType: MediaType!
  name: String
  saveOnServer: Boolean
  url: String
}

enum NotificationDeliveryType {
  CRITICAL
  NORMAL
  SILENT
}

type NotificationPostpone {
  createdAt: DateTime!
  id: ID!
  message: Message!
  messageId: String!
  notification: Notification!
  notificationId: String!
  sendAt: DateTime!
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type NotificationServiceInfo {
  devicePlatform: DevicePlatform!
  service: NotificationServiceType!
}

"""Type of notification service (Push or Local)"""
enum NotificationServiceType {
  LOCAL
  PUSH
}

type OAuthProvider {
  additionalConfig: String
  authorizationUrl: String
  callbackUrl: String
  clientId: String!
  clientSecret: String!
  color: String
  createdAt: DateTime!
  iconUrl: String
  id: ID!
  isEnabled: Boolean!
  name: String!
  profileFields: [String!]
  scopes: [String!]!
  textColor: String
  tokenUrl: String
  type: OAuthProviderType!
  updatedAt: DateTime!
  userInfoUrl: String
}

type OAuthProviderPublicDto {
  color: String
  iconUrl: String
  id: String!
  name: String!
  textColor: String
  type: OAuthProviderType!
}

"""
Type of OAuth provider (GitHub, Google, Discord, Apple, Facebook, Microsoft, or custom)
"""
enum OAuthProviderType {
  APPLE
  APPLE_SIGNIN
  CUSTOM
  DISCORD
  FACEBOOK
  GITHUB
  GOOGLE
  LOCAL
  MICROSOFT
}

type PaginatedLogs {
  limit: Int!
  logs: [Log!]!
  page: Int!
  total: Int!
  totalPages: Int!
}

type PasswordResetResponseDto {
  message: String!
  success: Boolean!
}

type PayloadMapper {
  builtInName: PayloadMapperBuiltInType
  createdAt: DateTime!
  id: ID!
  jsEvalFn: String!
  name: String!
  requiredUserSettings: [UserSettingType!]
  updatedAt: DateTime!
  user: User
  userId: ID
}

"""Built-in payload mapper types"""
enum PayloadMapperBuiltInType {
  ZENTIK_ATLAS_STATUSPAGE
  ZENTIK_AUTHENTIK
  ZENTIK_EXPO
  ZENTIK_GITHUB
  ZENTIK_INSTATUS
  ZENTIK_RAILWAY
  ZENTIK_SERVARR
  ZENTIK_STATUS_IO
}

"""Permission enum for bucket access"""
enum Permission {
  ADMIN
  DELETE
  READ
  WRITE
}

input PostponeNotificationDto {
  minutes: Int!
  notificationId: String!
}

type PostponeResponseDto {
  createdAt: DateTime!
  id: String!
  notificationId: String!
  sendAt: DateTime!
}

type PublicAppConfig {
  emailEnabled: Boolean!
  oauthProviders: [OAuthProviderPublicDto!]!
  systemTokenRequestsEnabled: Boolean!
  uploadEnabled: Boolean!
}

type Query {
  allOAuthProviders: [OAuthProvider!]!
  attachment(id: ID!): Attachment!
  bucket(id: String!): Bucket!
  bucketPermissions(bucketId: String!): [EntityPermission!]!
  buckets: [Bucket!]!
  checkEmailStatus(email: String!): EmailStatusResponseDto!
  enabledOAuthProviders: [OAuthProviderPublicDto!]!
  entityExecution(id: String!): EntityExecution
  events(query: EventsQueryDto!): EventsResponseDto!
  getAccessToken(tokenId: String!): AccessTokenListDto!
  getAccessTokensForBucket(bucketId: String!): [AccessTokenListDto!]!
  getBackendVersion: String!
  """Get the download URL for a specific backup file"""
  getBackupDownloadUrl(filename: String!): String!
  getEntityExecutions(input: GetEntityExecutionsInput!): [EntityExecution!]!
  getResourcePermissions(input: GetResourcePermissionsInput!): [EntityPermission!]!
  getSystemToken(id: String!): SystemAccessTokenDto
  getUserAccessTokens: [AccessTokenListDto!]!
  getUserSessions: [SessionInfoDto!]!
  healthcheck: String!
  """Get invite code by ID"""
  inviteCode(id: String!): InviteCode!
  """Get invite codes for a resource"""
  inviteCodesForResource(resourceId: String!, resourceType: String!): [InviteCode!]!
  """List all available database backups"""
  listBackups: [BackupInfoDto!]!
  listSystemTokens: [SystemAccessTokenDto!]!
  """Get logs with pagination and filtering"""
  logs(input: GetLogsInput!): PaginatedLogs!
  me: User!
  messageAttachments(messageId: ID!): [Attachment!]!
  myAdminSubscription: [String!]
  mySystemAccessTokenRequests: [SystemAccessTokenRequest!]!
  notification(id: String!): Notification!
  notificationServices: [NotificationServiceInfo!]!
  notifications: [Notification!]!
  oauthProvider(id: String!): OAuthProvider!
  payloadMapper(id: String!): PayloadMapper!
  payloadMappers: [PayloadMapper!]!
  pendingPostpones: [NotificationPostpone!]!
  publicAppConfig: PublicAppConfig!
  serverFiles(path: String): [FileInfoDto!]!
  """Get a specific server setting by type"""
  serverSetting(configType: ServerSettingType!): ServerSetting
  """Get all server settings"""
  serverSettings: [ServerSetting!]!
  systemAccessTokenRequests: [SystemAccessTokenRequest!]!
  """Get total log count"""
  totalLogCount: Float!
  user(id: String!): User!
  userAttachments(userId: ID!): [Attachment!]!
  userDevice: UserDevice
  userDevices: [UserDevice!]!
  userNotificationStats(userId: String): UserNotificationStats!
  userSettings(deviceId: String): [UserSetting!]!
  userWebhooks: [UserWebhook!]!
  users: [User!]!
  webhook(id: ID!): UserWebhook!
}

input RedeemInviteCodeInput {
  """Invite code to redeem"""
  code: String!
}

type RefreshTokenResponse {
  accessToken: String!
  message: String
  refreshToken: String!
}

input RegisterDeviceDto {
  deviceId: String
  deviceModel: String
  deviceName: String
  deviceToken: String
  onlyLocal: Boolean
  osVersion: String
  platform: DevicePlatform!
  publicKey: String
  subscriptionFields: WebPushSubscriptionFieldsInput
}

input RegisterDto {
  email: String!
  firstName: String
  lastName: String
  locale: String
  password: String!
  username: String!
}

type RegisterResponse {
  accessToken: String
  emailConfirmationRequired: Boolean!
  message: String!
  refreshToken: String
  user: User!
}

input RequestEmailConfirmationDto {
  email: String!
  locale: String
}

input RequestPasswordResetDto {
  email: String!
  locale: String
}

input ResetPasswordDto {
  newPassword: String!
  resetToken: String!
}

"""Type of resource for permissions"""
enum ResourceType {
  BUCKET
  USER_WEBHOOK
}

input RevokeEntityPermissionInput {
  resourceId: String!
  resourceType: ResourceType!
  userEmail: String
  userId: String
  username: String
}

type ServerSetting {
  configType: ServerSettingType!
  createdAt: DateTime!
  id: ID!
  """Possible values for the setting (for enum-like settings)"""
  possibleValues: [String!]
  updatedAt: DateTime!
  """Boolean value for the setting, when applicable"""
  valueBool: Boolean
  """Numeric value for the setting, when applicable"""
  valueNumber: Float
  """String value for the setting, when applicable"""
  valueText: String
}

enum ServerSettingType {
  ApnBundleId
  ApnKeyId
  ApnPrivateKeyPath
  ApnProduction
  ApnPush
  ApnTeamId
  AttachmentsAllowedMimeTypes
  AttachmentsDeleteJobEnabled
  AttachmentsEnabled
  AttachmentsMaxAge
  AttachmentsMaxFileSize
  AttachmentsStoragePath
  BackupCronJob
  BackupEnabled
  BackupExecuteOnStart
  BackupMaxToKeep
  BackupStoragePath
  CorsCredentials
  CorsOrigin
  EmailEnabled
  EmailFrom
  EmailFromName
  EmailHost
  EmailPass
  EmailPort
  EmailSecure
  EmailType
  EmailUser
  EnableSystemTokenRequests
  FirebaseClientEmail
  FirebasePrivateKey
  FirebaseProjectId
  FirebasePush
  JwtAccessTokenExpiration
  JwtRefreshSecret
  JwtRefreshTokenExpiration
  JwtSecret
  LogLevel
  LogRetentionDays
  LogStorageEnabled
  MessagesDeleteJobEnabled
  MessagesMaxAge
  PrometheusEnabled
  PushNotificationsPassthroughServer
  PushPassthroughToken
  RateLimitBlockMs
  RateLimitForwardHeader
  RateLimitLimit
  RateLimitMessagesRps
  RateLimitMessagesTtlMs
  RateLimitTrustProxyEnabled
  RateLimitTtlMs
  ResendApiKey
  ServerFilesDirectory
  ServerStableIdentifier
  SystemTokenUsageStats
  VapidSubject
  WebPush
}

type SessionInfoDto {
  browser: String
  createdAt: DateTime!
  deviceName: String
  expiresAt: DateTime!
  id: ID!
  ipAddress: String
  isActive: Boolean!
  isCurrent: Boolean!
  lastActivity: DateTime!
  location: String
  loginProvider: OAuthProviderType
  operatingSystem: String
}

input SetBucketSnoozeMinutesInput {
  minutes: Float!
}

type SnoozeSchedule {
  days: [String!]!
  isEnabled: Boolean!
  timeFrom: String!
  timeTill: String!
}

input SnoozeScheduleInput {
  days: [String!]!
  isEnabled: Boolean!
  timeFrom: String!
  timeTill: String!
}

type Subscription {
  bucketCreated: Bucket!
  bucketDeleted: String!
  bucketUpdated: Bucket!
  entityPermissionUpdated(bucketId: String): EntityPermission!
  notificationCreated: Notification!
  notificationDeleted: String!
  notificationUpdated: Notification!
  userBucketUpdated(bucketId: String): UserBucket!
  userPasswordChanged: Boolean!
  userProfileUpdated: User!
}

type SystemAccessToken {
  calls: Float!
  createdAt: DateTime!
  description: String
  expiresAt: DateTime
  id: String!
  lastResetAt: DateTime
  maxCalls: Float!
  requester: User
  requesterId: String
  requesterIdentifier: String
  scopes: [String!]
  token: String
  tokenHash: String!
  totalCalls: Float!
  updatedAt: DateTime!
}

type SystemAccessTokenDto {
  calls: Float!
  createdAt: DateTime!
  description: String
  expiresAt: DateTime
  id: String!
  lastResetAt: DateTime
  maxCalls: Float!
  rawToken: String
  requester: User
  scopes: [String!]
  token: String
  totalCalls: Float!
  updatedAt: DateTime!
}

type SystemAccessTokenRequest {
  createdAt: DateTime!
  description: String
  id: String!
  maxRequests: Float!
  plainTextToken: String
  status: SystemAccessTokenRequestStatus!
  systemAccessToken: SystemAccessToken
  systemAccessTokenId: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

"""Status of a system access token request"""
enum SystemAccessTokenRequestStatus {
  APPROVED
  DECLINED
  PENDING
}

input UpdateAccessTokenDto {
  expiresAt: DateTime
  name: String!
  scopes: [String!]
}

input UpdateBucketDto {
  color: String
  description: String
  generateIconWithInitials: Boolean
  icon: String
  isProtected: Boolean
  isPublic: Boolean
  name: String
}

input UpdateDeviceTokenDto {
  newDeviceToken: String!
  oldDeviceToken: String!
}

input UpdateInviteCodeInput {
  """Expiration date (ISO string)"""
  expiresAt: String
  """Invite code ID"""
  id: String!
  """Maximum number of uses"""
  maxUses: Int
  """Permissions to grant"""
  permissions: [String!]
}

input UpdateOAuthProviderDto {
  additionalConfig: String
  authorizationUrl: String
  callbackUrl: String
  clientId: String
  clientSecret: String
  color: String
  iconUrl: String
  isEnabled: Boolean
  name: String
  profileFields: [String!]
  scopes: [String!]
  textColor: String
  tokenUrl: String
  type: OAuthProviderType
  userInfoUrl: String
}

input UpdatePayloadMapperDto {
  jsEvalFn: String
  name: String
  requiredUserSettings: [UserSettingType!]
}

input UpdateProfileInput {
  avatar: String
  firstName: String
  lastName: String
}

type UpdateReceivedResult {
  success: Boolean!
  updatedCount: Float!
}

input UpdateServerSettingDto {
  valueBool: Boolean
  valueNumber: Float
  valueText: String
}

input UpdateUserDeviceInput {
  deviceId: String!
  deviceModel: String
  deviceName: String
  deviceToken: String
  osVersion: String
  subscriptionFields: WebPushSubscriptionFieldsInput
}

input UpdateUserRoleInput {
  role: UserRole!
  userId: String!
}

input UpdateWebhookDto {
  body: JSON
  headers: [WebhookHeaderDto!]
  method: HttpMethod
  name: String
  url: String
}

input UpsertUserSettingInput {
  configType: UserSettingType!
  deviceId: String
  valueBool: Boolean
  valueText: String
}

type User {
  accessTokens: [UserAccessToken!]
  avatar: String
  buckets: [Bucket!]
  createdAt: DateTime!
  devices: [UserDevice!]
  email: String!
  emailConfirmationToken: String
  emailConfirmationTokenRequestedAt: DateTime
  emailConfirmed: Boolean!
  firstName: String
  hasPassword: Boolean!
  id: ID!
  identities: [UserIdentity!]
  lastName: String
  resetToken: String
  resetTokenRequestedAt: DateTime
  role: UserRole!
  sessions: [UserSession!]
  updatedAt: DateTime!
  userBuckets: [UserBucket!]
  username: String!
  webhooks: [UserWebhook!]
}

type UserAccessToken {
  createdAt: DateTime!
  expiresAt: DateTime
  id: String!
  isExpired: Boolean!
  lastUsed: DateTime
  name: String!
  scopes: [String!]
  token: String
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type UserBucket {
  bucket: Bucket!
  bucketId: String!
  createdAt: DateTime!
  id: ID!
  magicCode: String
  snoozeUntil: DateTime
  snoozes: [SnoozeSchedule!]
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type UserDevice {
  createdAt: DateTime!
  deviceModel: String
  deviceName: String
  deviceToken: String
  id: ID!
  lastUsed: DateTime!
  onlyLocal: Boolean!
  osVersion: String
  platform: String!
  privateKey: String
  publicKey: String
  subscriptionFields: WebPushSubscriptionFields
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type UserIdentity {
  avatarUrl: String
  createdAt: DateTime!
  email: String
  id: ID!
  metadata: String
  providerType: OAuthProviderType
  updatedAt: DateTime!
  user: User!
  userId: String!
}

type UserNotificationStats {
  last7Days: Float!
  last7DaysAcked: Float!
  last30Days: Float!
  last30DaysAcked: Float!
  thisMonth: Float!
  thisMonthAcked: Float!
  thisWeek: Float!
  thisWeekAcked: Float!
  today: Float!
  todayAcked: Float!
  total: Float!
  totalAcked: Float!
}

"""User role enum"""
enum UserRole {
  ADMIN
  MODERATOR
  USER
}

type UserSession {
  browser: String
  createdAt: DateTime!
  deviceName: String
  exchangeCode: String
  exchangeCodeRequestedAt: DateTime
  expiresAt: DateTime!
  id: ID!
  ipAddress: String
  isActive: Boolean!
  lastActivity: DateTime
  loginProvider: OAuthProviderType
  operatingSystem: String
  tokenId: String!
  updatedAt: DateTime!
  user: User!
  userAgent: String
  userId: String!
}

type UserSetting {
  configType: UserSettingType!
  createdAt: DateTime!
  device: UserDevice
  deviceId: String
  id: ID!
  updatedAt: DateTime!
  user: User!
  userId: String!
  """Boolean value for the setting, when applicable"""
  valueBool: Boolean
  """String value for the setting, when applicable"""
  valueText: String
}

enum UserSettingType {
  AutoAddDeleteAction
  AutoAddMarkAsReadAction
  AutoAddOpenNotificationAction
  DefaultPostpones
  DefaultSnoozes
  ExpoKey
  GithubEventsFilter
  HomeassistantToken
  HomeassistantUrl
  Language
  ServerStableIdentifier
  Timezone
  UnencryptOnBigPayload
}

type UserWebhook {
  body: JSON
  createdAt: DateTime!
  headers: [WebhookHeader!]!
  id: ID!
  method: HttpMethod!
  name: String!
  updatedAt: DateTime!
  url: String!
  user: User!
}

type WebPushSubscriptionFields {
  auth: String
  endpoint: String
  p256dh: String
}

input WebPushSubscriptionFieldsInput {
  auth: String
  endpoint: String
  p256dh: String
}

type WebhookHeader {
  key: String!
  value: String!
}

input WebhookHeaderDto {
  key: String!
  value: String!
}